AWSTemplateFormatVersion: '2010-09-09'

Description: ECS Cluster Application Version

Parameters:
  Name:
    Type: String
    Description: Name of this Application
    ConstraintDescription: Must be DNS friendly
    AllowedPattern: ^[a-zA-Z][a-zA-Z0-9\-]+$
  ClusterName:
    Type: String
    Description: Name of the ECS cluster to use
    ConstraintDescription: Must be DNS friendly
    AllowedPattern: ^[a-zA-Z][a-zA-Z0-9\-]+$
  Environment:
    Description: Environment
    Type: String
    Default: Dev
    AllowedValues:
      - Dev
      - QA
      - PreProd
      - Production
      - CoreProd
  Version:
    Type: String
  HealthCheckPath:
    Description: Healthcheck Path used on TargetGroup
    Type: String
    Default: /
  HealthCheckGracePeriod:
    Description: The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started.
    Type: Number
    Default: 60
  TaskDefinitionArn:
    Description: ARN of Task Definition revision to Deploy to this service
    Type: String
  ContainerPort:
    Description: Port container listens
    Type: String
  RulePriority:
    Description: Listerner Rule Priority
    Type: Number
  DeregistrationDelay:
    Description: Target Group Deregistration Delay timeout in seconds
    Type: Number
    Default: 30
  Autoscaling:
    Description: Enable Autoscaling
    Type: String
    Default: Disable
    AllowedValues:
      - Enable
      - Disable
  AutoscalingTargetValue:
    Description: Target CPU for Autoscaling
    Type: Number
    Default: 75
  AutoscalingMaxSize:
    Description: Max number of containers to autoscale
    Type: Number
    Default: 16
  AutoscalingMinSize:
    Description: Min number of containers to autoscale
    Type: Number
    Default: 2
  Domain:
    Description: Domain name, only used for output
    Type: String
    Default: undefined
  Path:
    Description: Application path, only used for output
    Type: String
    Default: undefined
  AlbScheme:
    Description: Is the ALB internal or internet-facing?
    Type: String
  LBType:
    Description: Type of load balancer
    Type: String
    AllowedValues:
      - None
      - ALB
      - NLB

Conditions:
  isAutoscaling: !Equals [ !Ref Autoscaling, 'Enable']
  isInternal: !Equals
    - !Ref AlbScheme
    - 'internal'
  isALB: !Equals [!Ref LBType, ALB]
  isNLB: !Equals [!Ref LBType, NLB]
  isNoLB: !Equals [!Ref LBType, None]
  isLB: !Not ["Condition": isNoLB]

Resources:
  ALBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Condition: isALB
    Properties:
      HealthCheckIntervalSeconds: 10
      HealthCheckPath: !Ref HealthCheckPath
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 9
      HealthyThresholdCount: 2
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 5
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: !Ref DeregistrationDelay
      VpcId:
        Fn::ImportValue: !Sub "ecs-${ClusterName}-${Name}-${Environment}-VpcId"

  ListenerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Condition: isALB
    Properties:
      Actions:
        - Type: forward
          TargetGroupArn:
            Ref: ALBTargetGroup
      Conditions:
        - Field: host-header
          Values:
            - !Sub "${Name}-${Version}.*"
      ListenerArn:
        Fn::ImportValue: !Sub "ecs-${ClusterName}-${Name}-${Environment}-ALBListenerSSL"
      Priority: !Ref RulePriority

  ECSServiceLB:
    Type: AWS::ECS::Service
    DependsOn: ListenerRule  # The ECS Service will fail to deploy if the TG is not attached to a LB. This DependsOn fixes this.
    Condition: isLB
    Properties:
      TaskDefinition: !Ref TaskDefinitionArn
      DesiredCount: 1
      PlacementStrategies:
        - Type: spread
          Field:  attribute:ecs.availability-zone
        - Type: binpack
          Field: memory
      HealthCheckGracePeriodSeconds: !Ref HealthCheckGracePeriod
      Cluster:
        Fn::ImportValue: !Sub "ecs-${ClusterName}-ECSClusterArn"
      Role:
        Fn::ImportValue: !Sub "ecs-${ClusterName}-ECSServiceRole"
      LoadBalancers:
        - ContainerName: !Sub "${Name}"
          ContainerPort: !Ref ContainerPort
          TargetGroupArn: !Ref ALBTargetGroup

  # Because DependsOn can't be made conditional, we have to define ECSService twice - one for ALB and one without.
  ECSServiceNoLB:
    Type: AWS::ECS::Service
    Condition: isNoLB
    Properties:
      TaskDefinition: !Ref TaskDefinitionArn
      DesiredCount: 1
      Cluster:
        Fn::ImportValue: !Sub "ecs-${ClusterName}-ECSClusterArn"

  ServiceScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Condition: isAutoscaling
    Properties:
      MaxCapacity: !Ref AutoscalingMaxSize
      MinCapacity: !Ref AutoscalingMinSize
      ResourceId: !Sub
        - "service/${ECSCluster}/${ServiceName}"
        - ECSCluster:
            "Fn::ImportValue": !Sub "ecs-${ClusterName}-ECSCluster"
          ServiceName: !If
            - isNoLB
            - !GetAtt ECSServiceNoLB.Name
            - !GetAtt ECSServiceLB.Name
      RoleARN:
        "Fn::ImportValue": !Sub "ecs-${ClusterName}-ECSAutoscalingRoleArn"
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs

  ServiceScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Condition: isAutoscaling
    Properties:
      PolicyName: !Sub '${AWS::StackName}-scale-target-response-time'
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref 'ServiceScalingTarget'
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: !Ref AutoscalingTargetValue
        ScaleInCooldown: 180
        ScaleOutCooldown: 60
        CustomizedMetricSpecification:
          MetricName: TargetResponseTime
          Namespace: AWS/ApplicationELB
          Statistic: Average
          Dimensions:
            - Name: TargetGroup
              Value: !GetAtt ALBTargetGroup.TargetGroupFullName
            - Name: LoadBalancer
              Value:
                Fn::ImportValue: !Sub "ecs-${ClusterName}-${Name}-${Environment}-ALBFullName"

  # Target tracking does not ever scale down on missing data, so we have to create our own trigger to scale down
  ServiceScalingNoRequests:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Condition: isAutoscaling
    Properties:
      PolicyName: !Sub '${AWS::StackName}-scale-target-no-requests'
      PolicyType: StepScaling
      ScalingTargetId: !Ref 'ServiceScalingTarget'
      StepScalingPolicyConfiguration:
        AdjustmentType: ChangeInCapacity
        Cooldown: 180
        StepAdjustments:
          - ScalingAdjustment: -2
            MetricIntervalLowerBound: 0  # scale down no matter what
          - ScalingAdjustment: -2
            MetricIntervalUpperBound: 0

  AlarmResponseTimeNoRequests:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: No requests
      MetricName: RequestCount
      Namespace: AWS/ApplicationELB
      Statistic: Average
      Period: '60'
      EvaluationPeriods: '1'
      Threshold: '2'
      ComparisonOperator: LessThanOrEqualToThreshold
      AlarmActions:
        - Ref: ServiceScalingNoRequests
      Dimensions:
        - Name: TargetGroup
          Value: !GetAtt ALBTargetGroup.TargetGroupFullName
        - Name: LoadBalancer
          Value:
            Fn::ImportValue: !Sub "ecs-${ClusterName}-${Name}-${Environment}-ALBFullName"

  ServiceScalingPolicyCPU:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Condition: isAutoscaling
    Properties:
      PolicyName: !Sub '${AWS::StackName}-scale-target-cpu'
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref 'ServiceScalingTarget'
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 90
        ScaleInCooldown: 180
        ScaleOutCooldown: 60
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization

  ServiceScalingPolicyMem:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Condition: isAutoscaling
    Properties:
      PolicyName: !Sub '${AWS::StackName}-scale-target-mem'
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref 'ServiceScalingTarget'
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 95
        ScaleInCooldown: 180
        ScaleOutCooldown: 60
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageMemoryUtilization

  Route53ALB:
    Type: AWS::Route53::RecordSet
    Condition: isInternal
    Properties:
      Name: !Sub
        - "${Name}-${Version}.${HostedZoneName}"
        - HostedZoneName: !ImportValue
            Fn::Sub: "ecs-${ClusterName}-${Name}-${Environment}-HostedZoneName"
      HostedZoneName:
        Fn::ImportValue: !Sub "ecs-${ClusterName}-${Name}-${Environment}-HostedZoneName"
      Type: A
      AliasTarget:
        HostedZoneId:
          Fn::ImportValue: !Sub "ecs-${ClusterName}-${Name}-${Environment}-ALBCanonicalHostedZoneID"
        DNSName:
          Fn::ImportValue: !Sub "ecs-${ClusterName}-${Name}-${Environment}-ALBDNSName"

Outputs:
  Url:
    Condition: isALB
    Value: !Sub "https://${Name}-${Version}.${Domain}${Path}"
    Description: URL for the version of this app
  Version:
    Value: !Ref Version
    Description: The version used for this CloudFormation stack
